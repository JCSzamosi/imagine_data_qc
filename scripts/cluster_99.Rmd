Cluster Protocol
================

## Setup 

```{r Setup, include=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
library(DECIPHER)
library(dada2)
library(tidyverse)
library(phyloseq)
```

### Import Data

```{r}
load('cleaned/ps_samfilt.Rdata')
ls()
```

### Reduce to just a few taxa

```{r}
taxtab = data.frame(tax_table(ps_samfilt))
table(taxtab$Family)
ps_reduced = prune_taxa(taxtab$Family %in% c('Prevotellaceae', 'Veillonellaceae'),
                        ps_samfilt)
ps_reduced
summary(sample_sums(ps_reduced))
ps_reduced = prune_samples(sample_sums(ps_reduced) > 0, ps_reduced)
head(taxa_names(ps_reduced))
seqs_reduced = seqs_samfilt[taxa_names(ps_reduced)]
```


```{r}
seqs = DNAStringSet(seqs_reduced)
clusts = Clusterize(seqs, cutoff = 0.01, method = 'longest', includeTerminalGaps = TRUE,
          minCoverage = 0.99, processors = 10, verbose = TRUE)
dim(clusts)
head(clusts)
clusts %>% count(cluster) %>% arrange(desc(n)) %>% head()

cl_30 = rownames(filter(clusts, cluster == 30))
cl_30

seqs_30 = seqs_reduced[cl_30]
seqs_30 = DNAStringSet(seqs_30)
seqs_30

aln_30 = AlignSeqs(seqs_30, processors = 10)
BrowseSeqs(aln_30)

cl_134 = rownames(filter(clusts, cluster == 134))
cl_134

seqs_134 = seqs_reduced[cl_134]
seqs_134 = DNAStringSet(seqs_134)
seqs_134

aln_134 = AlignSeqs(seqs_134, processors = 10)
BrowseSeqs(aln_134)
```

There's also the TreeLine option. I think this might be the same as IdClusters?

```{r}
aln_reduced = AlignSeqs(seqs, processors = 10)
BrowseSeqs(aln_reduced)

dmat_reduced = DistanceMatrix(aln_reduced, type = 'dist', processors = 10)

clsts = TreeLine(aln_reduced, dmat_reduced, cutoff = 0.01, method = 'UPGMA',
                 type = 'clusters', processors = 10)

dim(clsts)
head(clsts)

clsts %>% count(cluster) %>% arrange(desc(n)) %>% filter(cluster == 212)
cl_27 = rownames(filter(clsts, cluster == 27))
cl_27

sum(cl_27 %in% cl_30)
sum(cl_30 %in% cl_27)

cl_30[!cl_30 %in% cl_27]

clsts[c('sp15709', 'sp20261'),]
clsts %>% filter(cluster %in% c(25, 158))

clsts['sp20462',]

```

These two methods produce very similar results and both seem fine. I think it is 
reasonable to replace IdClusters with TreeLine.

### Prep the sequences

```{r}
# # Host sequences get in the way of alignment. Remove them.
# taxtab = data.frame(tax_table(ps_samfilt))
# rownames(taxtab) = seqs_samfilt[rownames(taxtab)]
# nohost = (taxtab
# 	%>% mutate(Seq = rownames(.))
# 	%>% filter(!is.na(Phylum),
# 			   Kingdom %in% c('Bacteria','Archaea')))
# 
# # Get the sequences on their own for clustering
# seqs = as.character(nohost$Seq)
```

### Cluster the sequences

```{r}
# # Start by making a multisequence alignment of the ASVs
# aln = AlignSeqs(DNAStringSet(seqs), processors = 10)
load(file = 'intermed/aln_samfilt.Rdata')

# It's not a bad idea to look at the alignment and make sure it's not too bad
# BrowseSeqs(aln)

# Create a distance matrix 
dmat = DistanceMatrix(aln, type = 'dist', processors = 10)

# Cluster sequences using UPGMA method (splits the difference between
# "complete" and "single" method with a maximum between-cluster difference of
# 0.01)
clsts = Clusterize(dmat, cutoff = 0.01, method = 'UPGMA')
head(clsts)
	# Each sequence has its own row, in the order they were originally listed in
	# The cluster number that each sequence belongs to is listed in its row in
	# the "cluster" column

# Count the clusters
n_distinct(clsts$cluster)

# Add the sequences to the data frame so we can make consensus sequences
clsts$seqs = seqs
head(clsts)

# Count the number of clusters of each size
clsts %>% count(cluster, name = 'size') %>% count(size, name = 'count')
```

### Get a consensus sequence for each cluster, using ambiguity codes

```{r}
# A function to convert a set of sequences into a consensus sequence
get_conseq = function(x){
	if (length(x) > 1){
		aln = AlignSeqs(DNAStringSet(x))
	} else {
		aln = DNAStringSet(x)
	}
	con = ConsensusSequence(aln)
	return(as.character(con))
}

conseq = (clsts
		  %>% group_by(cluster)
		  %>% summarize(consensus = get_conseq(seqs)))

head(conseq)
```

### Assign taxonomy to the consensus sequence

```{r}
clstax = assignTaxonomy(conseq$consensus, 
			refFasta = '~/Disk2/CommonData/SILVA/silva_nr_v132_train_set.fa',
			tryRC = TRUE, multithread = 8)

head(clstax)
```

### Group up the ASV table into a cluster table

```{r}
head(clsts)

# Turn the ASV table into a data frame and add the sequences as a column
asvdf = (asvtab
		  %>% data.frame()
		  %>% mutate(seqs = rownames(.))
		  %>% select(seqs, everything()))
head(asvdf)

# Join with the cluster table
asvdf = (asvdf
		  %>% left_join(clsts, by = 'seqs')
		  %>% select(cluster, everything(), -seqs))
head(asvdf)

# Sum the counts at each sample within each cluster. This groups all the 'host'
# sequences into an NA cluster, which I then filter out
clstdf = (asvdf
		%>% group_by(cluster)
		%>% summarise_all(sum)
		%>% ungroup()
		%>% filter(!is.na(cluster))
		%>% data.frame())
dim(clstdf)

# Add the cluster consensus sequences as the rownames of the new table 
all(conseq$cluster == clstdf$cluster)
rownames(clstdf) = conseq$consensus
head(clstdf)

# Make it a matrix just like dada2 produces
clstab = as.matrix(select(clstdf, -cluster))
clstab[1:10,1:10]
```

### Done

Now we have a cluster count table `clstab`, and an associated taxonomy table
`clstax` and should be able to put them in phyloseq and do stuff.

```{r}

```
